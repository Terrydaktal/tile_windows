#!/usr/bin/env bash
set -euo pipefail

ROWS="${1:-1}"
# WM_CLASS substring(s) (case-insensitive).
# If omitted, defaults to "xfce4-terminal".
# If explicitly set to empty string, match all visible windows.
MATCH="${2-xfce4-terminal}"
GAP=3                        # fixed gap between all windows (px)

if ! [[ "$ROWS" =~ ^[0-9]+$ ]] || [ "$ROWS" -lt 1 ]; then
  echo "Usage: tile_windows [rows>=1] [wm_class_substrings]" >&2
  echo "  wm_class_substrings: comma-separated (e.g. firefox,xfce4-terminal). Empty string means: all visible windows." >&2
  exit 2
fi

for bin in python3 wmctrl xdotool xprop xwininfo xdpyinfo; do
  command -v "$bin" >/dev/null || { echo "Missing: $bin" >&2; exit 2; }
done

# ----- helpers -------------------------------------------------------------

get_screen_wh() {
  local out
  out="$(xdotool getdisplaygeometry 2>/dev/null || true)"
  if [[ "$out" =~ ^[0-9]+[[:space:]]+[0-9]+$ ]]; then
    echo "$out"
    return
  fi
  out="$(xdpyinfo | awk '/dimensions:/ {print $2; exit}')"
  echo "${out%x*} ${out#*x}"
}

# x y w h for a window (client geom; borderless == usable)
win_geom() {
  xwininfo -id "$1" 2>/dev/null | awk '
    /Absolute upper-left X:/ {x=$NF}
    /Absolute upper-left Y:/ {y=$NF}
    /^  Width:/ {w=$NF}
    /^  Height:/ {h=$NF}
    END {print x+0, y+0, w+0, h+0}
  '
}

# Workarea from wmctrl -d: WA: x,y WxH
get_workarea_from_wmctrl() {
  local desk="$1"
  wmctrl -d | awk -v d="$desk" '
    $1==d {
      for (i=1;i<=NF;i++) if ($i=="WA:") {
        split($(i+1),a,",");
        split($(i+2),b,"x");
        print a[1]+0, a[2]+0, b[1]+0, b[2]+0
        exit
      }
    }'
}

# If WA equals full screen (panel not reserving struts), subtract xfce4-panel geometry.
compute_workarea_with_panel_subtract() {
  local sx="$1" sy="$2" sw="$3" sh="$4"
  local top=0 bottom=0 left=0 right=0
  local ids

  ids="$(xdotool search --class xfce4-panel 2>/dev/null || true)"
  [ -z "$ids" ] && { echo "$sx $sy $sw $sh"; return; }

  while read -r wid; do
    [ -z "$wid" ] && continue
    read -r x y w h < <(win_geom "$wid") || continue

    if (( y <= 3 && w >= sw-10 )); then (( h > top )) && top="$h"; fi
    if (( y + h >= sh-3 && w >= sw-10 )); then (( h > bottom )) && bottom="$h"; fi
    if (( x <= 3 && h >= sh-10 )); then (( w > left )) && left="$w"; fi
    if (( x + w >= sw-3 && h >= sh-10 )); then (( w > right )) && right="$w"; fi
  done <<<"$ids"

  local wx=$(( sx + left ))
  local wy=$(( sy + top ))
  local ww=$(( sw - left - right ))
  local wh=$(( sh - top - bottom ))
  (( ww < 1 )) && ww=1
  (( wh < 1 )) && wh=1
  echo "$wx $wy $ww $wh"
}

# ----- desktop -------------------------------------------------------------

DESK="$(xprop -root _NET_CURRENT_DESKTOP 2>/dev/null | awk -F'= ' '{print $2}' || true)"
DESK="${DESK:-0}"

# ----- collect windows -----------------------------------------------------

trim() {
  local s="$1"
  # Trim leading/trailing whitespace.
  s="${s#"${s%%[![:space:]]*}"}"
  s="${s%"${s##*[![:space:]]}"}"
  printf '%s' "$s"
}

MATCH_LC="${MATCH,,}"
MATCH_ALL=0
MATCHES=()
if [ -z "${MATCH_LC}" ]; then
  MATCH_ALL=1
else
  IFS=',' read -r -a MATCHES <<<"$MATCH_LC"
fi
WIDS=()

while read -r wid; do
  wdesk="$(xprop -id "$wid" _NET_WM_DESKTOP 2>/dev/null | awk -F'= ' '{print $2}' | tr -d ',' || true)"
  wdesk="${wdesk:-$DESK}"
  [[ "$wdesk" != "$DESK" && "$wdesk" != "-1" ]] && continue

  cls="$(xprop -id "$wid" WM_CLASS 2>/dev/null | sed -n 's/.*= //p' || true)"
  [[ -z "${cls:-}" ]] && continue

  if (( MATCH_ALL )); then
    WIDS+=("$wid")
  else
    cls_lc="${cls,,}"
    for pat in "${MATCHES[@]}"; do
      pat="$(trim "$pat")"
      [ -z "${pat}" ] && continue
      if [[ "$cls_lc" == *"$pat"* ]]; then
        WIDS+=("$wid")
        break
      fi
    done
  fi
done < <(xdotool search --onlyvisible --name '.*' 2>/dev/null || true)

COUNT="${#WIDS[@]}"
if (( COUNT == 0 )); then
  if (( MATCH_ALL )); then
    echo "No visible windows found on this desktop." >&2
  else
    echo "No visible windows matched WM_CLASS containing: $MATCH" >&2
  fi
  echo "Check with: xprop -id \$(xdotool getactivewindow) WM_CLASS" >&2
  exit 1
fi

(( ROWS > COUNT )) && ROWS="$COUNT"

# ----- workarea ------------------------------------------------------------

read -r SW SH < <(get_screen_wh)
SX=0; SY=0

WA="$(get_workarea_from_wmctrl "$DESK" || true)"
if [ -n "$WA" ]; then
  read -r WORK_X WORK_Y WORK_W WORK_H <<<"$WA"
else
  WORK_X=$SX; WORK_Y=$SY; WORK_W=$SW; WORK_H=$SH
fi

# If WA still equals full screen, subtract panel(s)
if (( WORK_X==SX && WORK_Y==SY && WORK_W==SW && WORK_H==SH )); then
  read -r WORK_X WORK_Y WORK_W WORK_H < <(compute_workarea_with_panel_subtract "$SX" "$SY" "$SW" "$SH")
fi

# ----- build window centers + target cells ---------------------------------

tmpdir="$(mktemp -d)"
trap 'rm -rf "$tmpdir"' EXIT

win_tsv="$tmpdir/windows.tsv"
map_tsv="$tmpdir/map.tsv"

: > "$win_tsv"
for wid in "${WIDS[@]}"; do
  read -r x y w h < <(win_geom "$wid")
  cx=$(( x + w / 2 ))
  cy=$(( y + h / 2 ))
  printf "%s\t%d\t%d\n" "$wid" "$cx" "$cy" >> "$win_tsv"
done

# ----- assign windows to nearest row, then tile within that row -------------

python3 - "$win_tsv" "$WORK_X" "$WORK_Y" "$WORK_W" "$WORK_H" "$ROWS" "$GAP" > "$map_tsv" <<'PY'
import sys

win_file = sys.argv[1]
work_x, work_y, work_w, work_h, rows, gap = map(int, sys.argv[2:])

wins = []
with open(win_file, "r", encoding="utf-8") as f:
    for line in f:
        wid, cx, cy = line.rstrip("\n").split("\t")
        wins.append((wid, int(cx), int(cy)))

if not wins:
    raise SystemExit(0)

if rows > len(wins):
    rows = len(wins)

usable_h = work_h - (rows - 1) * gap
if usable_h < 1:
    raise SystemExit("Gap too large for height.")

h_base = usable_h // rows
h_rem = usable_h % rows

row_y = []
row_h = []
row_cy = []
for r in range(rows):
    h = h_base + (1 if r < h_rem else 0)
    y = work_y + r * (h_base + gap) + (r if r < h_rem else h_rem)
    row_y.append(y)
    row_h.append(h)
    row_cy.append(y + h // 2)

rows_wins = [[] for _ in range(rows)]
for wid, cx, cy in wins:
    best_r = 0
    best_d = abs(cy - row_cy[0])
    for r in range(1, rows):
        d = abs(cy - row_cy[r])
        if d < best_d:
            best_d = d
            best_r = r
    rows_wins[best_r].append((wid, cx, cy))

for r in range(rows):
    row_list = rows_wins[r]
    if not row_list:
        continue
    row_list.sort(key=lambda t: t[1])  # left-to-right
    cols = len(row_list)
    usable_w = work_w - (cols - 1) * gap
    if usable_w < 1:
        raise SystemExit("Gap too large for width.")
    w_base = usable_w // cols
    w_rem = usable_w % cols

    for c, (wid, _cx, _cy) in enumerate(row_list):
        w = w_base + (1 if c < w_rem else 0)
        x = work_x + c * (w_base + gap) + (c if c < w_rem else w_rem)
        y = row_y[r]
        h = row_h[r]
        print(f"{wid}\t{x}\t{y}\t{w}\t{h}")
PY

# ----- apply geometry (client geometry; borderless windows) -----------------

while IFS=$'\t' read -r wid x y w h; do
  wmctrl -i -r "$wid" -b remove,maximized_vert,maximized_horz,fullscreen 2>/dev/null || true
  xdotool windowsize "$wid" "$w" "$h"
  xdotool windowmove "$wid" "$x" "$y"
done < "$map_tsv"
